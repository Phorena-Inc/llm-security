#!/usr/bin/env python3
"""
Enhanced Graphiti Privacy Bridge with Timezone Awareness
======================================================

This module bridges Team C's privacy ontology with Graphiti knowledge graph storage.
Uses Graphiti's higher-level abstraction for natural language to Cypher translation
with proper timestamp handling and timezone awareness for global team integration.

Key Features:
- Timezone-aware timestamp formatting for Graphiti LLM processing
- Business hours consideration for policy enforcement
- Natural language episode content for better LLM translation
- Proper ISO 8601 timestamp formatting with Z suffix

Author: Team C Privacy Firewall
Date: 2024-12-30
"""

import sys
import os
import json
from pathlib import Path
import uuid
from datetime import datetime, timezone
import asyncio
from typing import Dict, List, Any, Optional

# Add parent directory to path
parent_dir = str(Path(__file__).parent.parent)
sys.path.append(parent_dir)

# Add Graphiti core path
graphiti_path = str(Path(__file__).parent.parent.parent / "graphiti_core")
sys.path.append(graphiti_path)

try:
    from graphiti_core import Graphiti
    from graphiti_core.nodes import EntityNode, EpisodicNode, EpisodeType
    from graphiti_core.edges import EntityEdge, EpisodicEdge
    from graphiti_core.utils.datetime_utils import utc_now
    GRAPHITI_AVAILABLE = True
    print("✅ Graphiti core imported successfully")
except ImportError as e:
    print(f"⚠️  Graphiti core not available: {e}")
    print("   Falling back to direct Neo4j for now...")
    GRAPHITI_AVAILABLE = False
    from neo4j import AsyncGraphDatabase

# Import privacy ontology and timezone utilities
from ontology.privacy_ontology import AIPrivacyOntology
from integration.timezone_utils import TimezoneHandler

class EnhancedGraphitiPrivacyBridge:
    """
    Enhanced privacy bridge with timezone awareness and proper timestamp handling.
    
    Uses Graphiti's higher-level abstraction with LLM-powered natural language
    to Cypher translation, ensuring proper temporal data for policy enforcement.
    """
    
    def __init__(self, neo4j_uri="bolt://localhost:7687", 
                 neo4j_user="neo4j", neo4j_password="12345678"):\n        self.neo4j_uri = neo4j_uri\n        self.neo4j_user = neo4j_user\n        self.neo4j_password = neo4j_password\n        self.ontology = AIPrivacyOntology()\n        \n        if GRAPHITI_AVAILABLE:\n            self._init_graphiti()\n        else:\n            self._init_neo4j_fallback()\n    \n    def _init_graphiti(self):\n        \"\"\"Initialize Graphiti for high-level abstraction.\"\"\"\n        try:\n            self.graphiti = Graphiti(\n                uri=self.neo4j_uri,\n                user=self.neo4j_user,\n                password=self.neo4j_password\n            )\n            self.use_graphiti = True\n            print(f\"✅ Graphiti initialized at {self.neo4j_uri}\")\n            print(\"   Using high-level abstraction with LLM-powered Cypher translation\")\n        except Exception as e:\n            print(f\"⚠️  Graphiti initialization failed: {e}\")\n            print(\"   Falling back to Neo4j...\")\n            self._init_neo4j_fallback()\n    \n    def _init_neo4j_fallback(self):\n        \"\"\"Initialize Neo4j fallback for development.\"\"\"\n        self.driver = AsyncGraphDatabase.driver(\n            self.neo4j_uri,\n            auth=(self.neo4j_user, self.neo4j_password)\n        )\n        self.use_graphiti = False\n        print(f\"✅ Neo4j fallback initialized at {self.neo4j_uri}\")\n    \n    async def create_privacy_decision_episode(self, privacy_request: dict):\n        \"\"\"\n        Create privacy decision record with timezone-aware timestamps.\n        \n        Uses Graphiti's natural language processing and timing data for policy enforcement.\n        Includes business hours and location context for global team integration.\n        \"\"\"\n        \n        # Make privacy decision using ontology\n        decision = self.ontology.make_privacy_decision(\n            requester=privacy_request[\"requester\"],\n            data_field=privacy_request[\"data_field\"], \n            purpose=privacy_request[\"purpose\"],\n            context=privacy_request.get(\"context\"),\n            emergency=privacy_request.get(\"emergency\", False)\n        )\n        \n        if self.use_graphiti:\n            return await self._create_episode_with_graphiti(privacy_request, decision)\n        else:\n            return await self._create_episode_neo4j_fallback(privacy_request, decision)\n    \n    async def _create_episode_with_graphiti(self, privacy_request: dict, decision: dict):\n        \"\"\"\n        Create privacy decision episode using Graphiti's high-level abstraction.\n        \n        Uses natural language content with proper timestamp formatting for LLM-powered Cypher translation.\n        Includes timezone awareness for global team integration.\n        \"\"\"\n        try:\n            episode_id = str(uuid.uuid4())\n            \n            # Get timezone-aware timestamp using Graphiti's datetime utilities\n            current_time = utc_now() if GRAPHITI_AVAILABLE else TimezoneHandler.get_current_utc()\n            requester_location = privacy_request.get('requester_location', 'utc')\n            \n            # Create properly formatted episode content following conversation pattern\n            # This follows the shoe_conversation examples you provided\n            formatted_timestamp = TimezoneHandler.format_for_graphiti(current_time, requester_location)\n            \n            episode_content = f\"\"\"PrivacyBot ({formatted_timestamp}): Privacy decision processed for data access request.\n\nRequester ({formatted_timestamp}): {privacy_request['requester']} requested access to {privacy_request['data_field']} for {privacy_request['purpose']}\n\nPrivacyBot ({formatted_timestamp}): Decision: {'ALLOWED' if decision.get('allowed', False) else 'DENIED'}\nReason: {decision.get('reason', 'No reason provided')}\nConfidence: {decision.get('confidence', 0.0)}\nContext: {privacy_request.get('context', 'General request')}\nEmergency Override: {'Active' if privacy_request.get('emergency', False) else 'None'}\n\nBusinessContext ({formatted_timestamp}): {TimezoneHandler.get_business_context(requester_location, current_time)}\"\"\"\n            \n            # Create EpisodicNode with timezone-aware timing data\n            episode_node = EpisodicNode(\n                name=f\"Privacy Decision: {privacy_request['data_field']} at {formatted_timestamp}\",\n                content=episode_content,\n                labels=[\"PrivacyDecision\", \"TeamC\", \"TimezoneAware\"],\n                uuid=episode_id,\n                group_id=\"team_c_privacy\",\n                source=EpisodeType.message if GRAPHITI_AVAILABLE else \"message\",\n                source_description=\"Team C Privacy Firewall Decision\",\n                created_at=current_time,\n                valid_at=current_time  # When this privacy decision was made\n            )\n            \n            # Add episode to Graphiti\n            await self.graphiti.add_episodic_nodes([episode_node])\n            \n            # Create data entity for the requested field\n            data_classification = self.ontology.classify_data_field(\n                privacy_request[\"data_field\"],\n                privacy_request.get(\"context\")\n            )\n            \n            await self._create_data_entity_with_graphiti(\n                privacy_request[\"data_field\"], \n                data_classification,\n                current_time\n            )\n            \n            print(f\"✅ Created Graphiti privacy decision episode: {episode_id}\")\n            print(f\"   Decision: {'ALLOWED' if decision['allowed'] else 'DENIED'}\")\n            print(f\"   Timestamp: {formatted_timestamp}\")\n            print(f\"   Location context: {requester_location}\")\n            print(f\"   Using Graphiti high-level abstraction with timing data\")\n            \n            return decision\n            \n        except Exception as e:\n            print(f\"⚠️  Graphiti episode creation failed: {e}\")\n            print(\"   Falling back to Neo4j...\")\n            return await self._create_episode_neo4j_fallback(privacy_request, decision)\n    \n    async def _create_data_entity_with_graphiti(self, data_field: str, classification: dict, timestamp: datetime):\n        \"\"\"\n        Create data entity using Graphiti's EntityNode abstraction.\n        \n        Uses timezone-aware descriptive content for LLM understanding and proper temporal tracking.\n        \"\"\"\n        try:\n            entity_id = str(uuid.uuid4())\n            \n            # Create descriptive entity content with timestamp following conversation pattern\n            formatted_timestamp = TimezoneHandler.format_for_graphiti(timestamp)\n            \n            entity_summary = f\"\"\"DataClassifier ({formatted_timestamp}): Classified data field '{data_field}'\n\nClassification Results ({formatted_timestamp}):\n- Data Type: {classification.get('data_type', 'Unknown')}\n- Sensitivity Level: {classification.get('sensitivity_level', 'Unknown')} \n- PII Status: {'Contains PII' if classification.get('is_pii', False) else 'No PII detected'}\n- Confidence: {classification.get('confidence', 0.0)}\n- Reasoning: {classification.get('reasoning', 'Automated classification')}\n\nSystemNote ({formatted_timestamp}): This data asset has been processed by Team C's Privacy Ontology for access control and policy enforcement.\"\"\"\n            \n            # Create EntityNode with timezone-aware descriptive content\n            data_entity = EntityNode(\n                name=f\"{data_field}\",\n                summary=entity_summary,\n                labels=[\"DataField\", \"ClassifiedAsset\", \"TimezoneAware\", classification.get('data_type', 'Unknown')],\n                uuid=entity_id,\n                group_id=\"team_c_privacy\",\n                created_at=timestamp\n            )\n            \n            # Add entity to Graphiti\n            await self.graphiti.add_entity_nodes([data_entity])\n            \n            print(f\"✅ Created Graphiti data entity: {data_field}\")\n            \n        except Exception as e:\n            print(f\"⚠️  Graphiti data entity creation failed: {e}\")\n    \n    async def _create_episode_neo4j_fallback(self, privacy_request: dict, decision: dict):\n        \"\"\"Fallback method using direct Neo4j access with timezone awareness.\"\"\"\n        current_time = TimezoneHandler.get_current_utc()\n        formatted_timestamp = TimezoneHandler.format_for_graphiti(current_time)\n        \n        async with self.driver.session() as session:\n            result = await session.run(\"\"\"\n                CREATE (e:PrivacyDecisionEpisode {\n                    uuid: $uuid,\n                    name: $name,\n                    requester: $requester,\n                    data_field: $data_field,\n                    purpose: $purpose,\n                    context: $context,\n                    decision: $decision,\n                    reason: $reason,\n                    confidence: $confidence,\n                    emergency: $emergency,\n                    timestamp: $timestamp,\n                    iso_timestamp: $iso_timestamp,\n                    created_at: datetime($created_at),\n                    team: 'C'\n                })\n                RETURN e.uuid as episode_id\n            \"\"\", \n                uuid=str(uuid.uuid4()),\n                name=f\"Privacy Decision: {privacy_request['data_field']}\",\n                requester=privacy_request[\"requester\"],\n                data_field=privacy_request[\"data_field\"],\n                purpose=privacy_request[\"purpose\"],\n                context=privacy_request.get(\"context\", \"\"),\n                decision=\"ALLOWED\" if decision[\"allowed\"] else \"DENIED\",\n                reason=decision[\"reason\"],\n                confidence=decision[\"confidence\"],\n                emergency=privacy_request.get(\"emergency\", False),\n                timestamp=formatted_timestamp,\n                iso_timestamp=current_time.isoformat(),\n                created_at=current_time.isoformat()\n            )\n            \n            print(f\"✅ Created Neo4j privacy decision (fallback)\")\n            print(f\"   Decision: {'ALLOWED' if decision['allowed'] else 'DENIED'}\")\n            print(f\"   Timestamp: {formatted_timestamp}\")\n            \n            return decision\n    \n    async def classify_data_field(self, data_field: str, context: str = None):\n        \"\"\"Classify data field using ontology with timezone tracking.\"\"\"\n        current_time = TimezoneHandler.get_current_utc()\n        \n        classification = self.ontology.classify_data_field(data_field, context)\n        \n        if self.use_graphiti:\n            await self._create_data_entity_with_graphiti(data_field, classification, current_time)\n        \n        return classification\n    \n    async def close(self):\n        \"\"\"Close connections properly.\"\"\"\n        if self.use_graphiti:\n            try:\n                await self.graphiti.close()\n                print(\"✅ Graphiti connection closed\")\n            except Exception as e:\n                print(f\"⚠️  Error closing Graphiti: {e}\")\n        else:\n            try:\n                await self.driver.close()\n                print(\"✅ Neo4j connection closed\")\n            except Exception as e:\n                print(f\"⚠️  Error closing Neo4j: {e}\")\n\n# Create instance for backward compatibility\nGraphitiPrivacyBridge = EnhancedGraphitiPrivacyBridge